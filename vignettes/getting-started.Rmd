---
title: "Getting Started with rbabylon"
author: "Seth Green"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{getting-started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r cleanup top, include=FALSE}
# delete old files
cleanup <- function() {
  if (fs::file_exists("../inst/nonmem/1.yaml")) fs::file_delete("../inst/nonmem/1.yaml")
  if (fs::file_exists("../inst/nonmem/2.yaml")) fs::file_delete("../inst/nonmem/2.yaml")
  if (fs::file_exists("../inst/nonmem/3.yaml")) fs::file_delete("../inst/nonmem/3.yaml")
  if (fs::file_exists("../inst/nonmem/2.ctl")) fs::file_delete("../inst/nonmem/2.ctl")
  if (fs::file_exists("../inst/nonmem/3.ctl")) fs::file_delete("../inst/nonmem/3.ctl")
  if (fs::dir_exists("../inst/nonmem/2")) fs::dir_delete("../inst/nonmem/2")
  if (fs::dir_exists("../inst/nonmem/3")) fs::dir_delete("../inst/nonmem/3")
  if (fs::file_exists("../inst/nonmem/babylon.yaml")) fs::file_delete("../inst/nonmem/babylon.yaml")
}
cleanup()
```

# Introduction

This "Getting Started with rbabylon" vignette takes the user through some basic scenarios for modeling with NONMEM using `rbabylon`, introducing you to its standard workflow and functionality. 

```{r libraries}
library(rbabylon)
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(purrr))
```

`rbabylon` is an R interface for running `babylon`. `babylon` is (will be) a complete solution for managing projects involving modeling and simulation with a number of software solutions used in pharmaceutical sciences. Currently, only NONMEM is supported, so this vignette will only address that. 

# Setup

## Do once on your system

The _first time_ you use `rbabylon` on a system or disk, you must first install `babylon`, often aliased as `bbi`. The first time you are using it for a given project, you will also need to run `bbi_init()` in your modeling directory. 

To reiterate, there are two relevant paths for this section.

* `BBI_EXE_PATH` -- the path to the `babylon` executable file on your system.
* `MODEL_DIR` -- the root modeling directory where you will be running models with `rbabylon`

```{r, include = FALSE}
BBI_EXE_PATH <- read_bbi_path()
MODEL_DIR <- "../inst/nonmem"
```

```{r define dirs, eval = FALSE}
BBI_EXE_PATH <- "/data/apps/bbi" # this should be an absolute path
MODEL_DIR <- "../inst/nonmem"    # this should be relative to your working directory
```

### Installing babylon

You can install the `babylon` binary with:

```{r, eval = FALSE}
rbabylon::use_bbi()
```

This will install to the `/data/apps/` folder by default, which matches the `BBI_EXE_PATH` you just defined (and will use soon). If you have changed that, you can pass your custom path to the _directory_ where you want to put bbi like so `use_bbi("/some/other/dir")`. In that case, you would want to set `BBI_EXE_PATH = "/some/other/dir/bbi"`.

You can also check the [babylon documentation](https://github.com/metrumresearchgroup/babylon) for manual installation instructions.

If you're not sure if you have `babylon` installed, you can use `bbi_version()` to check. This will return the version number of your installation, if one is found, or an empty string if you do _not_ have `babylon` installed. You can also use `bbi_current_release()` to see the most current version available and run `use_bbi()` as specified above if you want to update.

### Initializing babylon

Next, initialize `babylon` by pointing it to your modeling directory, a working installation of NONMEM, and a default NONMEM version to use.

```{r setup, eval = FALSE}
bbi_init(.dir = MODEL_DIR,            # the root modeling directory
         .nonmem_dir = "/opt/NONMEM", # location of NONMEM installation
         .nonmem_version = "nm74gf")  # default NONMEM version to use
```

This will create a `babylon.yaml` file in your `MODEL_DIR` directory which contains a lot of default settings for running models, etc. Those settings will not be discussed here, but know that they can be modified globally by editing that file, or model-by-model as described in the "Passing arguments to bbi" section below.

## Do for each R session

Once `babylon` is installed and initialized, you will need to make `rbabylon` knows where to find it. This can be done by setting the following options:

```{r bbi_exe_path}
options(
  'rbabylon.bbi_exe_path' = BBI_EXE_PATH,
  'rbabylon.model_directory' = normalizePath(MODEL_DIR, mustWork = TRUE)
)
```

This must be set for every new R session, so it may be wise to **include the above snippet in your `.Rprofile`**, replacing the `BBI_EXE_PATH` and `MODEL_DIR` constants with the relevant paths from your system/project. Note that, if setting `'rbabylon.model_directory'` explicitly like this, you _must set it to an absolute path._ The recommended way to do this is to use `normalizePath("path/to/dir/")` where `"path/to/dir/"` is a relative path from the script location (in this case the `.Rprofile` location). That way the project will still be portable between different servers/disks.

*NOTE:* By setting the `rbabylon.model_directory` option, you will _not_ need to pass the full path to model files when calling functions like `read_model()` or `submit_model()`. Instead you will pass a path relative to the specified modeling directory. To be clear, it is not _necessary_ to set this option, but it is definitely a recommended convenience.


# Initial modeling run

## Create model object
To begin modeling, first create a model object. This is an S3 object with an accompanying YAML file, kept in your modeling directory. The YAML serves as the "record of truth" for the model, and will persist changes you make to the model as you go.

The `.yaml_path` argument should have the same name (but with a `.yaml` extension) as your base model control stream. For instance, the command below assumes you have a control stream name `1.ctl` or `1.mod` in the model directory you just defined. The `.description` argument is required and corresponds to what would be in the `$PROB` definition in a control stream.

```{r first model}
mod1 <- new_model(.yaml_path = "1.yaml", .description = "our first model")
```

The model object you have just created can be passed to various functions which you will see in a minute. If you ever need to recreate it, just run `mod1 <- read_model("1.yaml")` to rebuild it from the YAML. The first thing we will do is submit the model to be run.

## Submit model

```{r submit_model_fake, eval = FALSE}
mod1 %>% submit_model()
```

This will return a process object. We won't discuss this object in this vignette, but other documentation will show how it can be used to check on the model run in progress. Please note that **checking on a model run in progress is not fully implemented.** For now, users should check on their runs manually (by looking at the output directory) and only proceed to the next steps once it has successfully completed. 

### Passing arguments to bbi

There are a number of arguments that `babylon` can take to modify how models are run. You can print a list of available arguments using the `print_bbi_args()` helper function.

```{r print_bbi_args}
print_bbi_args()
```

These can be specified globally in the `babylon.yaml` file, and you can see the default values of them in that file. However, they can also be specified or changed for each model. This can be done in several ways:

* Specifying them in the model YAML file, under the heading `bbi_args:`
* Manually attaching them to a model object with `add_bbi_args()` or `replace_bbi_args`
* Passing them as a named list to the `.bbi_args` argument of one of the following functions
  * `new_model()`
  * `submit_model()`
  * `model_summary()`

See the docs for any of those functions for more details on usage and syntax.

### Overwriting output from a previously run model

It is common to run a model, make some tweaks to it, and then run it again. However, to avoid accidentally deleting model outputs, `rbabylon` will error by default if it sees existing output when trying to submit a model. To automatically overwrite any previous model output, just pass `overwrite = TRUE` to the `.bbi_args` argument described in the previous section. For example:

```{r overwrite true, eval = FALSE}
mod1 %>% submit_model(.bbi_args = list(overwrite = TRUE))
```

You can also change this setting globally by adding `overwrite: true` to the `babylon.yaml` file for your project.

## Summarize model
Once the model run has completed, users can get a summary object containing much of the commonly used diagnostic information in a named list.

```{r model_summary}
sum1 <- mod1 %>% model_summary()
print(names(sum1))
```

These elements can be accessed manually or extracted with built-in helper functions like so:

```{r param_estimates}
param_df1 <- sum1 %>% param_estimates()
param_df1
```

# Iteration

Much of the benefit of `rbabylon` is leveraged in the model iteration workflow, and the run log summaries that can be created afterwards. For example, imagine you look at these model results and want to begin iterating on them with a new model. 

If you are now in a new R session and no longer have your `mod1` object, you can easily rebuild it from the YAML file on disk. *NOTE:* You can pass either a character or integer to `read_model()`, `submit_model()`, etc. to identify your model, assuming that you have set your model directory correctly.

```{r read_model fake, eval=FALSE}
mod1 <- read_model(1)
```

Now the user can create a new model object, based on the original, copying and renaming the control stream in the process.

```{r copy_model 2}
mod2 <- mod1 %>% copy_model_from(.new_model = 2, 
                                 .description = "two compartment base model")
```

The new control stream file `2.ctl` can now be edited with the desired changes and then submitted and summarized exactly as above.

```{r submit 2, eval = FALSE}
mod2 %>% submit_model()
mod2 %>% model_summary()
```

After looking at these results, the user can add tags, which can later be used to organize your modeling runs.

```{r add_tags 2}
mod1 <- mod1 %>% add_tags("base model")
mod2 <- mod2 %>% add_tags(c("base model", "2 compartment"))
```

In addition to tags, the user can add decisions that can be referenced later.

```{r}
mod2 <- mod2 %>% 
  add_decisions("2 compartment model more appropriate than 1 compartment")
```


Now the iteration process continues. 

```{r copy_model 3}
mod3 <- mod2 %>% 
  copy_model_from(.new_model = 3, 
                  .description = "two compartment with residual errors")
```

Submit and summarize as before.

```{r submit 3, eval = FALSE}
mod3 %>% submit_model()
mod3 %>% model_summary()
```

Add tags and decisions for filtering in run log, described next.

```{r add_tags 3}
mod3 <- mod3 %>% 
        add_tags("2 compartment") %>%
        add_decisions("Added residual errors because it seemed like a good idea.")
```

# Run log

At any point, the user can easily construct a run log tibble to summarize all models run up to this point. 

Before we move on, note that there are also the `config_log()` and `summary_log()` functions, as well as `add_config()` and `add_summary()` which automatically join the columns output from those functions against the tibble output from `run_log()`.  See the **Further Reading** section below for links to vignettes demostrating those functions.

```{r run_log} 
log_df <- run_log()
log_df
```

The `run_log()` returns a tibble (called `log_df` in this example) which can be manipulated like any other tibble. However, several of the columns (`tags` and `based_on` for example) are list columns, which complicates how the user interacts with them. Future releases will have  helper functions to more seamlessly interact with `log_df`, but until then, we have provided some sample `tidyverse` code below.

## Viewing tags example

This example code displays a more human-readable version of the run log, with the tags collapsed to a character vector.

```{r run_log_cleanup} 
log_df %>% 
  group_by(absolute_model_path) %>% 
  mutate_at(.vars = vars(tags:decisions), 
                   ~ paste(unlist(.x), collapse=", ")) %>% 
  ungroup() %>% 
  select(absolute_model_path, tags, decisions)
```

## Filtering tags example

This code uses `purrr::map_lgl` to filter the run log to only rows containing a specific tag (`"2 compartment"`).

```{r filtering}
log_df %>% 
  filter(map_lgl(tags, ~ "2 compartment" %in% .x)) %>%
  select(absolute_model_path, description, tags, decisions)
```


```{r cleanup bottom, include=FALSE}
# delete old files
cleanup()
```

# Further reading

Hopefully this has given you a good start on understanding the capabilities and basic workflow of `rbabylon`. Please see the other vignettes for demonstrations of more advanced or specific functionality.

* [Using the based_on field](using-based-on.html) -- How to use the `based_on` field to track a model's ancestry through the model development process, as well how to leverage `config_log()` to check whether older models are still up-to-date.
* [Creating a Model Summary Log](using-summary-log.html) -- How to use `summary_log()` to extract model diagnostics like the objective function value, condition number, and parameter counts.
