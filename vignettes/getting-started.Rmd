---
title: "Getting Started with rbabylon"
author: "Seth Green"
date: "2020-03-20"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{getting-started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r cleanup top, include=FALSE}
# delete old files
# if feels like I shouldn't need to do this, but R CMD CHECK fails without it
if (fs::file_exists("../inst/nonmem/1.yaml")) fs::file_delete("../inst/nonmem/1.yaml")
if (fs::file_exists("../inst/nonmem/2.yaml")) fs::file_delete("../inst/nonmem/2.yaml")
if (fs::file_exists("../inst/nonmem/3.yaml")) fs::file_delete("../inst/nonmem/3.yaml")
if (fs::file_exists("../inst/nonmem/2.ctl")) fs::file_delete("../inst/nonmem/2.ctl")
if (fs::file_exists("../inst/nonmem/3.ctl")) fs::file_delete("../inst/nonmem/3.ctl")
if (fs::file_exists("../inst/nonmem/babylon.yaml")) fs::file_delete("../inst/nonmem/babylon.yaml")
```

# Introduction

`rbabylon` is an R interface for running `babylon`. `babylon` is (will be) a complete solution for managing projects involving modeling and simulation with a number of software solutions used in pharmaceutical sciences. Currently, only NONMEM is supported, so this vignette will only address that. 

This "Getting Started with rbabylon" vignette takes the user through some basic scenarios for modeling with NONMEM using `rbabylon`, introducing you to its standard workflow and functionality. 

# Setup

## Do once on your system

The _first time_ you use `rbabylon` on a system or disk, you must first install `babylon`, often aliased as `bbi`. The first time you are using it for a given project, you will also need to run `bbi_init()` in your modeling directory. 

To reiterate, there are two relevant paths for this section.

* `BBI_EXE_PATH` -- the path the `babylon` executable file on your system.
* `MODEL_DIR` -- the root modeling directory where you will be running models with `rbabylon`

```{r define dirs}
library(rbabylon)

BBI_EXE_PATH <- "/data/apps/bbi" # this should be an absolute path
MODEL_DIR <- "../inst/nonmem"    # this should be relative to your working directory
```

### Installing babylon

You can install the `babylon` binary with the `rbabylon::use_bbi(BBI_EXE_PATH)` command. You can also check the [babylon documentation](https://github.com/metrumresearchgroup/babylon) for manual installation instructions.

If you're not sure if you have `babylon` installed, you can use `bbi_version()` to check. This will return the version number of your installation, if one is found, or an empty string if you do _not_ have `babylon` installed. You can also use `bbi_current_release()` to see the most current version available and run `use_bbi()` as specified above if you want to update.

### Initializing babylon

Next, initialize `babylon` by pointing it to your modeling directory, a working installation of NONMEM, and a default NONMEM version to use.

```{r setup, eval=FALSE}
bbi_init(.dir = MODEL_DIR,            # the modeling directory, where your control streams are
         .nonmem_dir = "/opt/NONMEM", # location of NONMEM installation
         .nonmem_version = "nm74gf")  # default NONMEM version to use
```

This will create a `babylon.yaml` file in your `MODEL_DIR` directory which contains a lot of default settings for running models, etc. Those settings will not be discussed here, but know that they can be modified by editing that file. 

## Do for each R session

Once `babylon` is installed and initialized, you will need to make `rbabylon` knows where to find it. This can be done by setting the following options:

```{r bbi_exe_path}
options(
  'rbabylon.bbi_exe_path' = BBI_EXE_PATH,
  'rbabylon.model_directory' = normalizePath(MODEL_DIR, mustWork = TRUE)
)
```

This must be for every new R session, so it may be wise to **`include the above snippet in your `.Rprofile`**, replacing the `BBI_EXE_PATH` and `MODEL_DIR` constants with the relevant paths from your system/project. Note that, if setting them in `.Rprofile` instead of your script, the path passed to `rbabylon.model_directory` must be relative to your `.Rprofile` file.

*NOTE:* By setting the `rbabylon.model_directory` option, you will _not_ need to pass the full path to model files, but only the path relative to the specified modeling directory. This is not necessary, but it is definitely a recommended convenience.


# Initial Modeling Run

## Create Model Object
To begin modeling, first create a model object. This is an S3 object with an accompanying YAML file, kept in your modeling directory. The YAML serves as the "record of truth" for the model, and will persist changes you make to the model as you go.

The `.yaml_path` argument should have the same name (but with a `.yaml` extension) as your base model control stream. For instance, the command below assumes you have a control stream name `1.ctl` or `1.mod` in the model directory you just defined. The `.description` argument is required and corresponds to what would be in the `$PROB` definition in a control stream.

```{r first model}
mod1 <- new_model(.yaml_path = "1.yaml", .description = "our first model")
```

The model object you have just created can be passed to various functions which you will see in a minute. If you ever need to recreate it, just run `mod1 <- read_model("1.yaml")` to rebuild it from the YAML. The first thing we will do is submit the model to be run.

## Submit Model

```{r submit_model_real, include = FALSE}
mod1 %>% submit_model(.dry_run = TRUE)
```

```{r submit_model_fake, eval = FALSE}
mod1 %>% submit_model()
```

This will return a process object. We won't discuss this object in this vignette, but other documentation will show how it can be used to check on the model run in progress. Please note that, for this first release, **checking on a model run in progress is not fully implemented.** For now, users should check on their runs manually and only proceed to the next steps once it has successfully completed. 

## Summarize Model
Once the model run has completed, users can get a summary object containing much of the commonly used diagnostic information in a named list.

```{r model_summary}
sum1 <- mod1 %>% model_summary()
print(names(sum1))
```

These elements can be accessed manually or extracted with built-in helper functions like so:

```{r param_estimates}
param_df1 <- sum1 %>% param_estimates()
param_df1
```

# Iteration

Much of the benefit of `rbabylon` is leveraged in the model iteration workflow, and the run log summaries that can be created afterwards. For example, imagine you look at these model results and want to begin iterating on them with a new model. 

Imagine you are now in a new R session and no longer have your `mod1` object. You can easily rebuild it from the YAML file on disk. *NOTE:* You can pass either a character or integer to `read_model()`, `submit_model()`, etc. to identify your model, assuming that you have set your model directory correctly.

```{r read_model fake, eval=FALSE}
mod1 <- read_model(1)
```

Now the user can create a new model object, based on the original, copying and renaming the control stream in the process.

```{r copy_model 2}
mod2 <- mod1 %>% copy_model_from(.new_model = 2, 
                                 .description = "two compartment base model")
```

The new control stream file `2.ctl` can now be edited with the desired changes and then submitted and summarized exactly as above.

```{r submit 2, eval = FALSE}
mod2 %>% submit_model()
mod2 %>% model_summary()
```

After looking at these results, the user can add tags, which can later be used to organize your modeling runs.

```{r add_tags 2}
mod1 <- mod1 %>% add_tags("base model")
mod2 <- mod2 %>% add_tags(c("base model", "2 compartment"))
```

In addition to tags, the user can add decisions that can be referenced later.

```{r}
mod2 <- mod2 %>% 
  add_decisions("2 compartment model more appropriate than 1 compartment")
```


Now the iteration process continues. 

```{r copy_model 3}
mod3 <- mod2 %>% 
  copy_model_from(.new_model = 3, 
                  .description = "two compartment with residual errors")
```

Submit and summarize as before.

```{r submit 3, eval = FALSE}
mod3 %>% submit_model()
mod3 %>% model_summary()
```

Add tags and decisions for filtering in run log, described next.

```{r add_tags 3}
mod3 <- mod3 %>% 
        add_tags("2 compartment") %>%
        add_decisions("Added residual errors because it seemed like a good idea.")
```

# Run Log

At any point, the user can easily construct a run log tibble to summarize all 
models run up to this point.

```{r run_log} 
log_df <- run_log()
log_df
```

The `run_log()` returns a tibble (called `log_df` in this example) which can be manipulated
like any other tibble. However, several of the columns (`tags` and `based_on` for example) are
list columns, which complicates how the user interacts with them. Future releases will have 
helper functions to more seamlessly interact with `log_df`, but until then, we have provided
some sample `dplyr` code below.

## Viewing tags example

This example code displays a more human-readable version of the run log, with the tags collapsed to a 
character vector.

```{r run_log_cleanup} 
suppressPackageStartupMessages(library(dplyr))

log_df %>% 
  group_by(absolute_model_path) %>% 
  mutate_at(.vars = vars(tags:decisions), 
                   ~ paste(unlist(.x), collapse=", ")) %>% 
  ungroup() %>% 
  select(absolute_model_path, tags, decisions)
```

## Filtering tags example

This code uses `purrr::map_lgl` to filter the run log to only rows containing a specific tag (`"2 compartment"`).

```{r filtering}
log_df %>% 
  filter(purrr::map_lgl(tags, ~ "2 compartment" %in% .x)) %>%
  select(absolute_model_path, description, tags, decisions)
```

## Checking if models are up-to-date with config_log()

When `babylon` runs a model, it creates a file named `bbi_config.json` in the output directory. This file contains a lot of information about the state and configuration at runtime. Notably, it contains an md5 digest of both the model file _and_ the data file at run time. Users can compare this to the _current_ md5 hashes of these two files to check if any model or data files have changed _since the model was last run_. This serves as a check that the outputs are up-to-date with the model and data.

Users can call `config_log` directly, but it is likely more useful to use `run_log() %>% add_config()` to join the two together automatically.

```{r add_config fake prep, include=FALSE}
# read in original json (which was actually fake a.k.a. copied from somewhere else)
orig_json <- jsonlite::fromJSON(file.path(getOption("rbabylon.model_directory"), "1", "bbi_config.json"))

# fix data path (just in case)
orig_json$data_path <- stringr::str_replace(orig_json$data_path, "/data/", "/extdata/")

# copying the outputs from the original run 
# and setting model md5 to match control stream (remember this "original" is fake)
for (i in c("1", "2", "3")) {
  out_dir <- file.path(getOption("rbabylon.model_directory"), i)
  if (!fs::dir_exists(out_dir)) fs::dir_create(out_dir)
  new_json <- orig_json
  new_json$model_md5 <- tools::md5sum(ctl_ext(out_dir))
  readr::write_file(jsonlite::toJSON(new_json), file.path(out_dir, "bbi_config.json"))
}
```

```{r add_config}
log_df <- run_log() %>% add_config()
log_df
```

Then a user can easily check the md5's digests from the config log against those of the current files.

```{r check config md5}
# extract path to data files and model files
norm_data_paths <- fs::path_norm(file.path(log_df$absolute_model_path, log_df$data_path))
norm_model_paths <- get_model_path(log_df)

# get md5 digests and compare to those from config_log() columns
log_df <- log_df %>% mutate(
                        current_data_md5  = tools::md5sum(norm_data_paths),
                        data_md5_match    = .data$data_md5 == .data$current_data_md5,
                        current_model_md5  = tools::md5sum(norm_model_paths),
                        model_md5_match   = .data$model_md5 == .data$current_model_md5
                      )

log_df %>% select(absolute_model_path, data_md5_match, model_md5_match)
```

```{r cleanup bottom, include=FALSE}
# delete old files
# if feels like I shouldn't need to do this, but R CMD CHECK fails without it
if (fs::file_exists("../inst/nonmem/1.yaml")) fs::file_delete("../inst/nonmem/1.yaml")
if (fs::file_exists("../inst/nonmem/2.yaml")) fs::file_delete("../inst/nonmem/2.yaml")
if (fs::file_exists("../inst/nonmem/3.yaml")) fs::file_delete("../inst/nonmem/3.yaml")
if (fs::file_exists("../inst/nonmem/2.ctl")) fs::file_delete("../inst/nonmem/2.ctl")
if (fs::file_exists("../inst/nonmem/3.ctl")) fs::file_delete("../inst/nonmem/3.ctl")
if (fs::dir_exists("../inst/nonmem/2")) fs::dir_delete("../inst/nonmem/2")
if (fs::dir_exists("../inst/nonmem/3")) fs::dir_delete("../inst/nonmem/3")
if (fs::file_exists("../inst/nonmem/babylon.yaml")) fs::file_delete("../inst/nonmem/babylon.yaml")
```
