---
title: "Getting Started with bbr and Stan"
author: "Seth Green"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{getting-started-stan}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

This "Getting Started with bbr" vignette takes the user through some basic scenarios for modeling with Stan using `bbr`, introducing you to its standard workflow and functionality. 

```{r setup, include=FALSE}
# NOTE: if running chunks interactively we need to load the package first
#   because renv isolation prevents us from finding an bbr installation
if (interactive()) {
  devtools::load_all()
}
```
```{r load packages, results = 'hide', message=FALSE, warning=FALSE}
library(bbr)
library(dplyr)
library(purrr)
```

`bbr` is an R interface for running `bbi`. Together they provide a solution for managing projects involving modeling and simulation with a number of software solutions used in pharmaceutical sciences. Currently, only NONMEM and Stan are supported. For details on modeling in NONMEM, the ["Getting Started with bbr and NONMEM" vignette](https://metrumresearchgroup.github.io/bbr/articles/getting-started.html).

# Setup

```{r set paths and define cleanup, include = FALSE}
#options('bbr.bbi_exe_path' = read_bbi_path())
MODEL_DIR <- system.file("model", "stan", package = "bbr")

# delete old files
cleanup <- function() {
  # delete new model entirely
  if (fs::file_exists(file.path(MODEL_DIR, "fxaNew.yaml"))) fs::file_delete(file.path(MODEL_DIR, "fxaNew.yaml"))
  if (fs::dir_exists(file.path(MODEL_DIR, "fxaNew"))) fs::dir_delete(file.path(MODEL_DIR, "fxaNew"))
  
  # set up incomplete model
  if (fs::file_exists(file.path(MODEL_DIR, "fxaInc.yaml"))) {
    fs::file_delete(file.path(MODEL_DIR, "fxaInc.yaml"))
  }
  fs::file_copy(
    file.path(MODEL_DIR, "fxa.yaml"),
    file.path(MODEL_DIR, "fxaInc.yaml")
  )
  
  if (fs::dir_exists(file.path(MODEL_DIR, "fxaInc"))) fs::dir_delete(file.path(MODEL_DIR, "fxaInc"))
  fs::dir_create(file.path(MODEL_DIR, "fxaInc"))
  
  writeLines(STANINIT_SCAFFOLD_STRING, file.path(MODEL_DIR, "fxaInc", "fxaInc-init.R"))
  fs::file_copy(
    file.path(MODEL_DIR, "fxa", "fxa.stan"),
    file.path(MODEL_DIR, "fxaInc", "fxaInc.stan")
  )

  writeLines(
    "init <- function() {\n  list(param1 = c(1,2,3,4), param2 = c(5,6,7,8))\n}", 
    file.path(MODEL_DIR, "some_other_init.R")
  )

}
cleanup()
```


## Installing bbi
**DON'T NEED ANY OF THIS STUFF ABOUT BBI** but probably need a section about setting up `cmdstan`. Maybe just a little explanation and then link to [the `cmdstanr` docs](http://mc-stan.org/cmdstanr/articles/cmdstanr.html#installing-cmdstan-1).

# Initial modeling run

## Create model object
To begin modeling, first create a model object using `new_model()`. This is an S3 object which you will pass to all of the other `bbr` functions that submit, summarize, or manipulate models.

The first argument (`.path`) must be the path to the directory containing the necessary files. For Stan models, you will also have to add `.model_type = "stan"` to the the `new_model()` call.

```{r first model}
fxaNew <- new_model(file.path(MODEL_DIR, "fxaNew"), .model_type = "stan")
```

The call above will look for a directory called `{MODEL_DIR}/fxa_new`. _Inside_ this directory it will expect to find files like `fxaNew.stan` and `fxaNew-standata.R`. These "required files" will be discussed in more detail below. For now, notice that--if any of them are _not_ found when you initialize the model--`new_model()` will print a message to the console and create scaffolds (files with boilerplate non-working code) of the missing files.

You can use the `bbr::build_path_from_model()` function to take a look at any of these scaffolded files.

```{r, comment=""}
fxaNew %>% 
  build_path_from_model("-standata.R") %>%
  readLines() %>%
  cat(sep = "\n")
```

The purpose of this scaffold is to provide some helpful framework to begin writing the necessary code for submitting a model with `bbr`. Below (in the `copy_model_from()` section) you will see how, once you have defined a model or two, you can use those models as your starting point for new models, instead of relying on writing new code from scaffolds.

## The `bbr` YAML file

This `new_model()` call will also create an `fxa.yaml` file that will sit next to this directory on disk. This YAML file  stores model metadata like description and tags (discussed below). For now the YAML file will look very bare, but hopefully its purpose will become more clear later.

Note that if you _already have the relevant code for your new model_, you can manually create these files in the output directory _before_ calling `new_model()`. In that case, you won't see any of the messages shown above and the `new_model()` call will simply create the `.yaml` file next to your directory.

## Reading in an existing model

Now assume that you have previously created a model and written all the necessary code. You can read this model into memory with `read_model()`.

```{r}
fxaOld <- read_model(file.path(MODEL_DIR, "fxa"))
```

If take a look at _this model's_ `-standata.R` file, you can see an example of how this script might look in a real model.

```{r, comment=""}
fxaOld %>% 
  build_path_from_model("-standata.R") %>%
  readLines() %>%
  cat(sep = "\n")
```


### An incomplete model

Sometimes you will have created your model and begun writing code, but the model has not been fully defined. When you read in a model like this, you will see some messages that are similar to the ones we saw when we first called `new_model()` above.

```{r}
fxaInc <- read_model(file.path(MODEL_DIR, "fxaInc"))
```

In this (somewhat contrived) example, we see three different messages:

* The first tells us that we are missing the `-standata.R` file and points to helpful documentation for creating one.
* The second tells us that the `-init.R` file is only a scaffold and must be completed from the model can be submitted.
* And finally we're told that a scaffold has been added for the missing file(s) mentioned in the first message.

### Adding required files and using `check_stan_model()`

The user can manually check whether all the required files are present at any time by calling the `check_stan_model()` function.

```{r}
check_stan_model(fxaInc)
```

Notice that now we see that we have all our files, but that two of them are still scaffolds. There are several helper functions designed to make it easy to add these files to the model. You can read about all of them in the `?add_file_to_model_dir` documentation page.

By default, all of these functions will attempt to add a scaffold of the relevant file, erroring if there is already a (non-scaffold) file present. However, you can also supply a path to the `.source_file` argument, in order to copy a file from another location into a given model.

```{r}
fxaInc <- fxaInc %>% 
  add_stan_init(.source_file = file.path(MODEL_DIR, "some_other_init.R")) %>%    # copy from external file
  add_standata_file(.source_file = build_path_from_model(fxaOld, "-standata.R")) # copy from another model
```

Now we run `check_stan_model()` we get a clean bill of health.

```{r}
check_stan_model(fxaInc)
```



## Submit model

```{r}
#### WORK IN PROGRESS!!!!
nChains <- 4
nIter <- 500

fxa_res <- submit_stan_model_cmdstanr(
  fxaOld, 
  seed = 123456,
  chains = nChains,
  iter_sampling = nIter,
  .overwrite = TRUE
)

```


#### diagnostics from cmdstanr

```{r}
# this is just diagnostics
fxa_res$sampler_diagnostics() %>% str()
```


```{r}
# this pulls in the the actual posteriors
.s <- fxa_res$summary()
print(dim(.s))
#[1] 7731   10 !!!!!!!!!
```

```{r}
.s
```





### !!!!!

```{r submit_model_fake, eval = FALSE}
mod1 %>% submit_model()
```

This will return a process object. We won't discuss this object in this vignette, but it contains some information about the submission call. Please note that **checking on a model run in progress is not fully implemented.** For now, users should check on their runs manually (by looking at the output directory) and only proceed to the next steps once it has successfully completed. 

### Passing arguments to bbi

**WE PROBABLY DON'T NEED THIS SECTION** but it's not clear if we'll use this field to control parallelization or anything. Probably not, but want to make sure we consider that before we delete this.

### Overwriting output from a previously run model

**FOR EXAMPLE: THIS PART.** I'm not sure how `cmdstanr` deals with overwriting old posteriors, etc. Do we want to build this in or just let people overwrite by accident? Not sure.

_It is common to run a model, make some tweaks to it, and then run it again. However, to avoid accidentally deleting model outputs, `bbr` will error by default if it sees existing output when trying to submit a model. To automatically overwrite any previous model output, just pass `overwrite = TRUE` to the `.bbi_args` argument described in the previous section. For example:_

```{r overwrite true, eval = FALSE}
mod1 %>% submit_model(.bbi_args = list(overwrite = TRUE))
```

_You can also change this setting globally by setting `overwrite: true` in the `bbi.yaml` file for your project._

## Summarize model
Once the model run has completed, users can get a summary object containing much of the commonly used diagnostic information in a named list.

```{r model_summary}
sum1 <- mod1 %>% model_summary()
print(names(sum1))
```

These elements can be accessed manually or extracted with built-in helper functions like so:

```{r param_estimates}
param_df1 <- sum1 %>% param_estimates()
param_df1
```

To see how to load summaries of multiple models to an easy-to-read tibble, see the [Creating a Model Summary Log](https://metrumresearchgroup.github.io/bbr/articles/using-summary-log.html) vignette.

# Iteration

Much of the benefit of `bbr` is leveraged in the model iteration workflow, and the run log summaries that can be created afterwards. For example, imagine you look at these model results and want to begin iterating on them with a new model. 

If you are now in a new R session and no longer have your `mod1` object in memory, you can easily rebuild it from the YAML file on disk with `read_model()`:

```{r read_model fake, eval=FALSE}
mod1 <- read_model(file.path(MODEL_DIR, 1))
```

## copy_model_from()

Now you can create a new model object, based on the original, copying and renaming the control stream in the process. The `copy_model_from()` call below will create both `2.ctl` and `2.yaml` files in the same directory as the parent model, and return the model object corresponding to them. (`copy_model_from()` also stores the model's "ancestry" which can be useful later in the project, as shown in the [Using the based_on field](https://metrumresearchgroup.github.io/bbr/articles/using-based-on.html) vignette.)

```{r copy_model 2}
mod2 <- copy_model_from(mod1, 2)
```

Note that, while the `.path` argument in  `new_model()` and `read_model()` is relative to your working directory, the `.new_model` argument of `copy_model_from()` is _relative to the directory containing the parent model._ This means that, assuming you would like to create the new model in the same directory as its parent, you only have to pass a filename (without extension) for the new model. Since, by convention, scientists often name their models numerically, you can also pass a number, which will be coerced to the relevant file names internally.

The new control stream file `2.ctl` can now be edited with the desired changes and then submitted and summarized exactly as above.

```{r submit 2, eval = FALSE}
# manually edit control stream, then...
mod2 %>% submit_model()
mod2 %>% model_summary()
```

## Adding tags and notes

After looking at these results, the user can add tags, which can later be used to organize your modeling runs.

```{r add_tags 2}
mod1 <- mod1 %>% add_tags("orig acop model")
mod2 <- mod2 %>% add_tags("2 compartment")
```

Note that using free text for your tags is discouraged, for reasons mentioned in the `?modify_tags` help page. For simplicity's sake, we ignore that advice here, but please read it before using tags extensively in the wild.

In addition to tags, the user can add notes that can be referenced later.

```{r}
mod2 <- mod2 %>% 
  add_notes("2 compartment model more appropriate than 1 compartment")
```

## Continue to iterate...

Now the iteration process continues with a third model. Note that you can tell `copy_model_from()` to inherit the tags from the parent model and automatically add them to the new model.

```{r copy_model 3}
mod3 <- copy_model_from(mod2, 3, .inherit_tags = TRUE)
```

Submit and summarize as before.

```{r submit 3, eval = FALSE}
# manually edit control stream, then...
mod3 %>% submit_model()
mod3 %>% model_summary()
```

Add tags and notes for filtering in run log, described next.

```{r add_tags 3}
mod3 <- mod3 %>% 
        add_tags(c("combined RUV", "iiv CL")) %>%
        add_notes("Added combined error structure because it seemed like a good idea")
```

# Run log

At any point, the user can easily construct a "run log" tibble to summarize all models run up to this point. 

Before we move on, note that you can get even more information about your models from the `config_log()` and `summary_log()` functions, as well as `add_config()` and `add_summary()` which automatically join the columns output from those functions against the tibble output from `run_log()`.  See the "Further Reading" section below for links to vignettes demonstrating those functions.

```{r run_log} 
log_df <- run_log(MODEL_DIR)
log_df
```

The `run_log()` returns a tibble which can be manipulated like any other tibble. However, several of the columns (`tags`, `notes`, and `based_on` for example) are list columns, which complicates how you can interact with them. We provide some helper functions to more seamlessly interact with these log tibbles, as well as some sample `tidyverse` code below.

## Viewing tags example

The `bbr::collapse_to_string()` function can collapse any list column into a string representation of its contents. It is specifically designed for collapsing columns like `tags`, `notes`, and `based_on` into a more human-readable format.

```{r viewing tags new} 
log_df %>% 
  collapse_to_string(tags, notes) %>%
  select(run, tags, notes)
```


## Filtering tags example

This code uses `purrr::map_lgl` to filter the run log to only rows containing a specific tag (`"2 compartment"`).

```{r filtering}
log_df %>% 
  filter(map_lgl(tags, ~ "2 compartment" %in% .x)) %>%
  collapse_to_string(tags, notes) %>%
  select(run, tags, notes)
```


```{r cleanup bottom, include=FALSE}
# delete old files
cleanup()
```

# Further reading

Hopefully this has given you a good start on understanding the capabilities and basic workflow of `bbr`. Please see the other vignettes for demonstrations of more advanced or specific functionality.

* [Using the based_on field](https://metrumresearchgroup.github.io/bbr/articles/using-based-on.html) -- How to use the `based_on` field to track a model's ancestry through the model development process, as well how to leverage `config_log()` to check whether older models are still up-to-date.
* [Creating a Model Summary Log](https://metrumresearchgroup.github.io/bbr/articles/using-summary-log.html) -- How to use `summary_log()` to extract model diagnostics like the objective function value, condition number, and parameter counts.
