% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modify-model-field.R
\name{modify_model_field}
\alias{modify_model_field}
\alias{add_tags}
\alias{replace_tags}
\alias{add_decisions}
\alias{replace_decisions}
\alias{add_based_on}
\alias{replace_based_on}
\alias{replace_description}
\alias{add_bbi_args}
\alias{replace_bbi_args}
\title{Modify field in model object}
\usage{
modify_model_field(.mod, .field, .value, .append = TRUE, .unique = TRUE)

add_tags(.mod, .tags)

replace_tags(.mod, .tags)

add_decisions(.mod, .decisions)

replace_decisions(.mod, .decisions)

add_based_on(.mod, .based_on)

replace_based_on(.mod, .based_on)

replace_description(.mod, .description)

add_bbi_args(.mod, .bbi_args)

replace_bbi_args(.mod, .bbi_args)
}
\arguments{
\item{.mod}{The \verb{bbi_\{.model_type\}_model} object to modify}

\item{.field}{Character scaler of the name of the component to modify}

\item{.value}{Whatever is to be added to \code{.mod[[.field]]}, typically a character vector}

\item{.append}{If \code{TRUE}, the default, concatenate new values with currently present values. If \code{FALSE}, new values will overwrite old values.}

\item{.unique}{If \code{TRUE}, the default, de-duplicate \code{.mod[[.field]]} after adding new values. If \code{FALSE} duplicate values will be kept.}

\item{.decisions}{Character vector to use as replacement}

\item{.based_on}{Character vector of relative paths to add to \code{based_on} field}

\item{.description}{Character scalar to use as replacement for the \code{description} field}

\item{.bbi_args}{named list of arguments to add to the model}
}
\description{
Helper functions for updating fields in a \verb{bbi_\{.model_type\}_model} object.
Note that calling \code{modify_model_field()} directly is not recommended for most users
because it requires knowing about the internal structure of the model object.
Instead we recommend using the friendlier helpers listed below (\code{add_...} or \code{replace_...}) when possible.
}
\details{
All functions in this family also check the object against the corresponding YAML with \code{check_yaml_in_sync()} before modifying it,
and errors if they are out of sync.
After the object has been modified they will write the modified object back to the YAML and update the model object in
memory with an md5 digest of the newly written YAML.
}
\section{Functions}{
\itemize{
\item \code{add_tags}: Add tags to a model object and corresponding YAML

\item \code{replace_tags}: Replaces tags on a model object and corresponding YAML with new tags

\item \code{add_decisions}: Append new decisions to the one(s) in a model object and corresponding YAML

\item \code{replace_decisions}: Replaces \code{decisions} field in a model object and corresponding YAML with new values

\item \code{add_based_on}: Append new \code{based_on} tag to the one in a model object and corresponding YAML

\item \code{replace_based_on}: Replaces \code{based_on} field in a model object and corresponding YAML with new values

\item \code{replace_description}: Replaces description field in a model object and corresponding YAML with new description

\item \code{add_bbi_args}: Modifies model object and corresponding YAML by adding new \code{bbi_args},
overwriting any args that are already present with the new values.
Use \code{print_nonmem_args()} to see a list of valid babylon arguments.

\item \code{replace_bbi_args}: Modifies model object and corresponding YAML by replacing \code{bbi_args} with new list passed to \code{.bbi_args}.
Use \code{print_nonmem_args()} to see a list of valid babylon arguments.
}}

