% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modify-model-field.R
\name{modify_model_field}
\alias{modify_model_field}
\alias{replace_model_field}
\title{Modify field in model object}
\usage{
modify_model_field(
  .mod,
  .field,
  .value,
  .append = TRUE,
  .remove = FALSE,
  .unique = TRUE,
  .char_value = TRUE
)

replace_model_field(.mod, .field, .old_val, .new_val)
}
\arguments{
\item{.mod}{The \verb{bbi_\{.model_type\}_model} object to modify}

\item{.field}{Character scalar of the name of the component to modify}

\item{.value}{Whatever is to be added to \code{.mod[[.field]]}, typically a character vector (or a named list in the case of \verb{*_bbi_args()}).
If \code{NULL} or \code{NA} is passed and \code{.append = FALSE} then \code{.field} with be deleted from the object and corresponding YAML.}

\item{.append}{If \code{TRUE}, the default, concatenate new values with currently present values. If \code{FALSE}, new values will overwrite old values.}

\item{.remove}{If \code{TRUE}, \code{.value} with be removed from the \code{.field} instead of added. \code{FALSE} by default. Cannot have both \code{.append} and \code{.remove} be true in the same call.}

\item{.unique}{If \code{TRUE}, the default, de-duplicate \code{.mod[[.field]]} after adding new values. If \code{FALSE} duplicate values will be kept.}

\item{.char_value}{If \code{TRUE}, check that \code{.value} (after unlisting) is a character vector.}

\item{.old_val}{The value to be replaced. If \code{.old_val} is not present in
\code{.mod[[.field]]}, function will warn user and return \code{.mod} unchanged.}

\item{.new_val}{The value to insert in place of \code{.old_val} in
\code{.mod[[.field]]}.}
}
\description{
Helper functions for updating fields in a \verb{bbi_\{.model_type\}_model} object.
Note that calling \code{modify_model_field()} or \code{replace_model_field()} directly
is \emph{not} recommended for most users because it requires knowing about the
internal structure of the model object. Instead, \strong{we recommend using the
friendlier helpers listed below in "See also"} whenever possible.
}
\details{
All functions in this family also check the object against the corresponding
YAML with \code{check_yaml_in_sync()} before modifying it, and errors if they are
out of sync. After the object has been modified they will write the modified
object back to the YAML and update the model object in memory with an md5
digest of the newly written YAML.
}
\section{Functions}{
\itemize{
\item \code{replace_model_field}: Replace a single item in a model field
}}

\seealso{
\code{\link[=add_tags]{add_tags()}} \code{\link[=replace_tag]{replace_tag()}} \code{\link[=replace_all_tags]{replace_all_tags()}} \code{\link[=remove_tags]{remove_tags()}}
\code{\link[=add_notes]{add_notes()}} \code{\link[=replace_note]{replace_note()}} \code{\link[=replace_all_notes]{replace_all_notes()}} \code{\link[=remove_notes]{remove_notes()}}
\code{\link[=add_based_on]{add_based_on()}} \code{\link[=replace_all_based_on]{replace_all_based_on()}} \code{\link[=remove_based_on]{remove_based_on()}}
\code{\link[=add_description]{add_description()}} \code{\link[=replace_description]{replace_description()}} \code{\link[=add_bbi_args]{add_bbi_args()}}
\code{\link[=replace_all_bbi_args]{replace_all_bbi_args()}}
}
