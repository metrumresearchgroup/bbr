% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modify-records.R
\name{modify_records}
\alias{modify_records}
\alias{get_model_ctl}
\alias{get_records}
\alias{mod_has_record}
\alias{remove_records}
\alias{add_new_record}
\alias{modify_data_path_ctl}
\alias{modify_prob_statement}
\alias{get_input_columns}
\alias{get_table_columns}
\title{Modify or retrieve options and records from a \code{NONMEM} control stream file}
\usage{
get_model_ctl(.mod)

get_records(.mod, type, get_lines = FALSE)

mod_has_record(.mod, type)

remove_records(.mod, type)

add_new_record(
  .mod,
  type,
  rec_name = paste0("$", toupper(type), " "),
  lines = NULL,
  after = NULL
)

modify_data_path_ctl(.mod, data_path)

modify_prob_statement(.mod, prob_text = NULL)

get_input_columns(.mod, from_data = TRUE, filter_drop = FALSE)

get_table_columns(.mod, from_data = TRUE)
}
\arguments{
\item{.mod}{a bbr model object}

\item{type}{record type. This may be spelled any way that's accepted in a
\code{NONMEM} control stream.}

\item{get_lines}{Logical (T/F). If \code{TRUE}, return the lines as character
vectors (based on how they were defined in the control stream).}

\item{rec_name}{a character string defining the record name (e.g., \verb{$THETA})}

\item{lines}{a character string or vector of lines to append to the new
record. If passing a vector, creates a new line per index. Defaults to \code{NULL}.}

\item{after}{add new record after \emph{this record type}. This may be spelled
any way that's accepted in a \code{NONMEM} control stream. If \code{NULL}, append to
the end of the control stream. If multiple records are found, uses the last
index}

\item{data_path}{Data path to set in a \verb{$DATA} record.}

\item{prob_text}{If \code{NULL} return the current \verb{$PROBLEM} statement. If a
character string, set the problem statement to that value.}

\item{from_data}{Logical (T/F). If \code{TRUE}, the default, get the column names
from the first line of the referenced dataset (input data or table file). If
\code{FALSE}, parse the control stream and retrieve from the relevant record type
(\verb{$INPUT} or \verb{$TABLE}).}

\item{filter_drop}{Logical (T/F). If \code{TRUE}, remove columns set to \code{DROP}
or \code{SKIP} in the control stream's \verb{$INPUT} record. Only used if
\code{from_data = FALSE}.}
}
\description{
Modify or retrieve options and records from a \code{NONMEM} control stream file
}
\details{
\itemize{
\item \strong{\code{get_model_ctl()}} is called internally within the other functions, though
it can also be used outside of that context.
\item \strong{\code{modify_prob_statement()}}, \strong{\code{modify_data_path_ctl()}},
\strong{\code{remove_records()}}, and \strong{\code{add_new_record()}} read in the control stream,
make any modifications, and then save out the updated control stream.
\itemize{
\item \code{modify_prob_statement()} also returns a character string defining the
\verb{$PROBLEM} text (see \code{prob_text} argument).
}
\item \strong{\code{mod_has_record()}} will return a logical value denoting whether a \code{bbr}
model has a given record type.
\item \strong{\code{get_records()}} extracts all records of a given type. Note that it is
not meant to be used to modify existing records.
\item \strong{get_input_columns()} and \strong{get_table_columns()} extract the column names
of the input data and all table files respectively. They can either be parsed
from a \code{NONMEM} control stream file, or determined from reading in the
\code{csvs}/table files. See \code{from_data} argument for more details.
}
}
\section{Functions}{
\itemize{
\item \code{get_model_ctl()}: Read in a \code{NONMEM} control stream file, parsed via
\code{nmrec}

\item \code{get_records()}: Pull all records of a given record type from a
\code{bbr} model

\item \code{mod_has_record()}: Check if a \code{bbr} model has a given record type

\item \code{remove_records()}: Remove \emph{all records} of a given type from a \code{NONMEM}
control stream file

\item \code{add_new_record()}: Add a new record of a given type from a \code{NONMEM}
control stream file

\item \code{modify_data_path_ctl()}: Modify the specified data path in a \code{NONMEM}
control stream file

\item \code{modify_prob_statement()}: Modify or retrieve the \verb{$PROBLEM} statement from
a \code{NONMEM} control stream file.

\item \code{get_input_columns()}: Retrieve input data column names from either the
\verb{$INPUT} record in a \code{NONMEM} control stream file or the input dataset.

\item \code{get_table_columns()}: Retrieve table columns names from either \verb{$TABLE}
record(s) in a \code{NONMEM} control stream file or the tabled out files

}}
\note{
Run the following command to see what record types are available/supported by
\code{nmrec}:

\if{html}{\out{<div class="sourceCode">}}\preformatted{`ls(nmrec:::record_names)`
}\if{html}{\out{</div>}}
}
\examples{
\dontrun{

# Adding a new record
seed <- 1234; n <- 100
sim_lines <- glue("({seed}) SUBPROBLEMS={n} TRUE=FINAL ONLYSIMULATION")
add_new_record(.mod, "simulation", lines = sim_lines, after = "pred")


# Remove all records of a given type
if(mod_has_record(.mod, "table")) remove_records(.mod, "table")


# Modify or extract a problem statement
modify_prob_statement(.mod, prob_text = NULL)
#> [1] "PK model 1 cmt base"
modify_prob_statement(.mod, prob_text = "new problem")
#> [1] "new problem"

}
}
\seealso{
\code{\link[=assert_record_type]{assert_record_type()}}
}
\keyword{internal}
